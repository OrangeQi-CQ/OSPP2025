# 基于 Occlum 的 System V 信号量实现报告

## 1. 函数细节

### 1.1 核心数据结构方法

#### Semaphore结构体方法

`Semaphore`结构体代表单个信号量，包含以下主要方法：

- `new(initial_value: i32) -> Self`：创建新信号量，初始化计数值和等待队列
  - 参数：初始计数值
  - 功能：初始化信号量状态，设置初始计数值，创建空的等待队列，记录创建进程PID

- `check_op(&mut self, op: i32, pid: pid_t) -> bool`：检查操作是否可立即执行
  - 参数：操作值(op)、进程PID
  - 功能：
    - 对于正值操作(op>0)：总是可执行，返回true
    - 对于零操作(op=0)：若计数值为0则可执行，否则将进程加入等待队列并返回false
    - 对于负值操作(op<0)：若计数值+操作值≥0则可执行，否则将进程加入等待队列并返回false

- `do_op(&mut self, op: i32, pid: pid_t)`：执行信号量操作
  - 参数：操作值(op)、进程PID
  - 功能：更新计数值，从等待队列移除当前进程，记录最后操作进程PID

- `get_ncnt(&self) -> usize`：获取等待获取资源的进程数
- `get_zcnt(&self) -> usize`：获取等待计数值为0的进程数

#### SemSet结构体方法

`SemSet`结构体代表信号量集，包含以下主要方法：

- `new(...) -> Result<Self>`：创建新信号量集
  - 参数：信号量集ID、键值、信号量数量、权限模式
  - 功能：验证参数合法性，初始化信号量集元数据，创建指定数量的信号量

- 权限管理方法：`get_key()`、`set_perm()`、`get_perm()`
  - 功能：获取/设置信号量集的键值和权限信息，更新修改时间

- 进程关联方法：`attach_pid(pid: pid_t)`、`detach_pid(pid: &pid_t)`
  - 功能：维护与信号量集关联的进程集合，用于生命周期管理

- `do_semop(&self, sops: &[sembuf_t]) -> Result<()>`：执行信号量操作序列
  - 核心逻辑：循环检查所有操作是否可执行，若可执行则批量执行并唤醒等待进程，否则阻塞当前进程

- 信号量控制方法：`getval()`、`setval()`、`get_ncnt()`、`get_zcnt()`
  - 功能：获取/设置单个信号量的计数值，查询等待进程数量

#### SemIdManager结构体方法

`SemIdManager`负责信号量集ID的分配与回收：

- `new() -> Self`：初始化ID管理器
- `get_new_semid(&mut self) -> Result<SemId>`：分配新的信号量集ID
  - 功能：循环查找可用ID，更新已使用ID集合和计数器
- `free_semid(&mut self, shmid: &SemId) -> Result<()>`：回收信号量集ID

#### SemManager结构体方法

`SemManager`是全局信号量管理器，提供主要的外部接口：

- `do_semget(...) -> Result<SemId>`：创建或获取信号量集
  - 功能：根据键值和标志位创建新信号量集或获取已有集，处理权限检查和冲突判断

- `do_semop(...) -> Result<()>`：执行信号量操作
  - 功能：验证参数，关联进程与信号量集，调用`SemSet::do_semop`执行操作

- `do_semctl(...) -> Result<usize>`：信号量控制操作
  - 功能：根据命令参数执行多种控制操作，包括删除、设置权限、查询状态等

- `do_semdt(&self, semid: SemId) -> Result<usize>`：分离进程与信号量集
  - 功能：从信号量集移除当前进程关联，必要时删除信号量集

- 清理方法：`detach_sem_when_process_exit()`、`clean_when_libos_exit()`
  - 功能：进程退出或系统关闭时清理资源

### 1.2 系统调用映射

该实现提供了与标准System V信号量系统调用对应的功能：

- `semget` → `SemManager::do_semget`
- `semop` → `SemManager::do_semop`
- `semctl` → `SemManager::do_semctl`
- `semdt` → `SemManager::do_semdt`

## 2. 并发控制

本实现通过多种机制保证多进程/线程环境下的安全访问：

### 2.1 锁机制

1. **互斥锁（Mutex）**
   - 用于保护需要独占访问的共享数据
   - 应用场景：
     - `SemSet::perm`：保护权限信息的读写
     - `SemSet::sems`：保护信号量数组的修改
     - `SemSet::attached_pids`：保护关联进程集合的修改
     - `SemSet::waiter_queue`：保护等待队列的操作

2. **读写锁（RwLock）**
   - 用于读多写少的场景，提高并发效率
   - 应用场景：
     - `SemManager::sem_sets`：保护信号量集哈希表，读操作用读锁，修改用写锁
     - `SemManager::semid_manager`：保护ID管理器，分配/释放ID时用写锁

### 2.2 等待/唤醒机制

1. **WaiterQueue**：每个信号量集维护一个等待队列
   - 当操作无法立即执行时，进程被封装为`Waiter`加入队列
   - 调用`waiter.wait(None)`阻塞当前进程
   - 当条件满足时，调用`waiter_queue.dequeue_and_wake_all()`唤醒所有等待进程

2. **阻塞策略**：
   ```rust
   let waiter = Waiter::new();
   waiter_queue.reset_and_enqueue(&waiter);
   drop(sems);  // 释放锁，避免死锁
   drop(waiter_queue);
   waiter.wait(None);  // 阻塞当前进程
   ```
   - 释放锁后再阻塞，确保其他进程可以继续操作

### 2.3 原子操作

使用`Atomic`类型实现无锁同步：
- `AtomicI64`：用于`sem_otime`和`sem_ctime`时间戳的更新
- `AtomicBool`：用于`marked_for_removal`删除标记
- 原子操作使用`Ordering::Relaxed`内存顺序，平衡性能与安全性

## 3. 资源管理

### 3.1 信号量集生命周期

1. **创建**：通过`do_semget`创建，分配唯一ID，初始化元数据和信号量数组

2. **使用**：
   - 进程通过`do_semop`执行操作时自动关联到信号量集
   - 关联关系记录在`attached_pids`集合中

3. **删除**：
   - 标记删除：通过`semctl`的`IPC_RMID`命令标记为待删除
   - 延迟删除：仅当所有关联进程都已分离且标记为删除时才实际释放资源
   ```rust
   if marked_for_removal && is_empty {
       self.free_semid(&semid)?;
       let mut sem_sets = self.sem_sets.write().unwrap();
       sem_sets.remove(&semid);
   }
   ```

### 3.2 ID管理

`SemIdManager`负责信号量集ID的分配与回收：
- 维护已使用ID集合（`used_id`）和空闲计数（`free_num`）
- 采用循环分配策略，从上次分配ID的下一个位置开始查找
- 确保ID在`[0, SEMMNI)`范围内，且不重复

### 3.3 进程退出处理

- 进程退出时调用`detach_sem_when_process_exit`，自动从所有关联信号量集分离
- 系统退出时调用`clean_when_libos_exit`，释放所有信号量集资源

### 3.4 资源限制

通过常量定义系统资源限制：
- `SEMMNI`：最大信号量集数量（128）
- `SEMMSL`：每个集最大信号量数（250）
- `SEMMNS`：系统总信号量数上限（SEMMNI * SEMMSL）
- `SEMOPM`：每次semop调用的最大操作数（32）
- `SEMVMX`：信号量最大计数值（32767）

## 4. 原子性保证

### 4.1 semop操作的原子性

`semop`操作保证对多个信号量的操作要么全部执行，要么全部不执行：

1. **预检查阶段**：
   ```rust
   let mut all_ops_can_proceed = true;
   for sop in sops {
       // 检查每个操作是否可执行
       if !sems[sem_num].check_op(sop.sem_op as i32, pid) {
           all_ops_can_proceed = false;
           // 处理非阻塞情况
       }
   }
   ```
   - 对所有操作进行预检查，只有全部可执行时才继续

2. **原子执行**：
   ```rust
   if all_ops_can_proceed {
       for sop in sops {
           // 执行所有操作
           sem.do_op(sop.sem_op as i32, pid);
       }
       // 唤醒等待进程
       waiter_queue.dequeue_and_wake_all();
       return Ok(());
   }
   ```
   - 在持有锁的情况下批量执行所有操作
   - 操作完成后才释放锁，确保中间状态不被其他进程看到

3. **重试机制**：
   - 采用循环结构，被唤醒的进程会重新检查所有操作条件
   - 确保在并发环境下，操作的原子性不受其他进程干扰

### 4.2 关键状态的原子更新

- 时间戳更新：使用`AtomicI64::store`原子更新`sem_otime`和`sem_ctime`
- 删除标记：使用`AtomicBool::store`原子设置`marked_for_removal`
- 这些操作确保状态更新的不可分割性，避免竞态条件

## 5. 错误处理

实现了全面的错误检查和处理机制：

1. 参数验证：检查信号量索引范围、操作数限制、计数值范围等
2. 资源检查：检查信号量集是否存在、进程是否已关联等
3. 内存安全：使用`from_user::make_slice`安全复制用户空间数据
4. 错误码返回：使用`return_errno!`宏返回符合POSIX标准的错误码

常见错误包括：
- `EINVAL`：无效参数（如信号量索引越界）
- `E2BIG`：操作数超过SEMOPM限制
- `EAGAIN`：非阻塞模式下操作无法立即执行
- `ENOENT`：信号量集不存在
- `EEXIST`：创建已存在的信号量集（带IPC_EXCL标志）

## 6. 兼容性

本实现遵循System V信号量接口规范，与标准接口兼容：

1. 支持标准标志位：`IPC_CREAT`、`IPC_EXCL`、`IPC_NOWAIT`、`SEM_UNDO`等
2. 支持标准控制命令：`IPC_RMID`、`IPC_SET`、`IPC_STAT`等
3. 权限模型与标准文件权限兼容（`S_IRUSR`、`S_IWUSR`等）
