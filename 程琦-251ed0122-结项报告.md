# 项目报告：基于 Occlum 实现 System V 信号量系统调用

## 一、项目信息

项目名称：

- 基于 Occlum 实现 System V 信号量系统调用

项目产出要求

1. 本项目的目标是在 Occlum 中实现 System V 信号量机制（包括 semget、semctl、semop、semtimedop 等系统调用），使得 Occlum 能支持更多应用程序。

项目技术要求

1. 为 Occlum 支持 System V 信号量机制，包括 semget、semctl、semop、semtimedop 等系统调用。
2. 编写一些简单的测试应用程序，验证实现的正确性，给出性能测试结果。
3. 调研一到两个使用了System V信号量的真实世界应用程序，并尝试在Occlum中正确运行。
4. 编写实现与测试文档，输出报告。



## 二、项目进度

总体来看，原定计划基本完成。

1. 实现 semget、semctl、semop、semtimedop 4 个系统调用，核心代码位于 `src/ipc/sem.rs`。
2. 参考同为 IPC 模块的 `shm` 共享内存的测例，编写一份测例（包含`5` 个子测例，每个测例包含多个测试点），通过该测试。
3. 调研了 PostgreSQL，并尝试移植到 Occlum：PostgreSQL 作为经典的多进程架构数据库，大量依赖进程间同步机制来保证共享资源（如共享内存、数据缓冲区、锁表等）的并发访问安全性。System V 信号量是其早期版本中（至今仍可配置使用）用于进程同步的核心工具之一，主要用于控制多个后端进程对共享内存区域的互斥访问。
4. 编写完成实现和测试报告。



## 三、解决方案

### 3.1 系统调用功能

架构设计在代码中，系统调用表现遵循 System 约定。详见实现文档。

### 3.2 并发管理

主要是利用了 `occlum` 原有的的 `event` 组件，维护两个等待队列。

1. 等待队列（`WaiterQueue`）每个信号量集（`SemSet`）维护一个`waiter_queue`，用于存放因操作无法执行而阻塞的进程。在`do_semop`中，当操作无法立即执行（如`all_ops_can_proceed`为`false`），当前进程会被封装为`Waiter`加入队列，并调用`waiter.wait(None)`阻塞。释放锁后再阻塞，避免持有锁时阻塞导致的死锁（其他进程无法获取锁进行操作）。
2. 当信号量状态满足操作条件时（如资源释放），唤醒等待队列中的所有进程重新尝试操作：在`do_semop`中，执行完信号量操作后调用`waiter_queue.dequeue_and_wake_all()`，唤醒所有等待进程。被唤醒的进程会重新进入循环，检查操作是否可执行（因信号量状态可能已被其他进程修改），实现 “条件满足时重试” 的同步逻辑。

### 3.3 资源生命周期管理

主要包含两部分：

1. 进程关联与分离：每个信号量集通过`attached_pids`记录当前关联的进程 ID（通过`attach_pid`添加，`detach_pid`移除），确保只有关联进程能操作资源。进程退出时，调用`detach_sem_when_process_exit`自动从所有关联的信号量集中移除自身 ID，避免 “僵尸进程” 占用资源。
2. 延迟删除机制：当通过`IPC_RMID`标记信号量集删除时，不会立即释放资源，而是等待所有关联进程分离后再删除。这避免了并发访问已释放资源的问题（如进程正在操作时资源被删除）。

### 3.4 操作原子性保证

通过 “全执行或全阻塞” 的策略保证操作的原子性：

- 只有所有操作均可执行时，才会批量执行；否则，所有操作均不执行，当前进程阻塞。这样保证了 “同时获取两个资源” 不会出现 “获取一个后阻塞” 的中间状态）。



## 四、测试

### 4.1 基本测试

见测试文档

### 4.2 Linux Test Project (LTP)

见测试文档

### 4.3 PostgreSQL

见测试文档



## 五、未来规划

在接下来的时间（10.1~10.30）推进 pr/mr。主要工作：

1. 完善代码风格和细节。
2. 加强测例，排查隐藏的 bug。
3. 继续移植 PostgreSQL 到 Occlum