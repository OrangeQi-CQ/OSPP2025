## 测试环境

使用官方docker，将仓库挂在到docker中编译运行。

```bash
# 起动 docker
sudo docker run -it -v /home/cq/OSPP2025/occlum/:/root/occlum occlum/occlum:0.31.0-ubuntu20.04

# 编译
make submodule
SGX_MODE=SIM make

# 测试
SGX_MODE=SIM make test
```

## 一、基础测试

### 1.0 概述

本测试套件用于验证系统V信号量（System V Semaphore）的核心功能与异常场景处理能力。该套件通过多个独立测试用例，全面覆盖信号量的创建、获取、进程间同步、删除及资源回收等操作，确保信号量机制在各种场景下的正确性与稳定性。

测试套件采用父子进程协作模式：父进程负责创建测试环境并发起测试，子进程配合验证跨进程场景下的信号量行为，通过严格的错误码检查和状态验证确保测试有效性。

宏定义：

| 宏定义           | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| `S_IRWUSER`      | 信号量权限宏，组合`S_IRUSR`（用户读权限）和`S_IWUSR`（用户写权限） |
| `SEM_SET_SIZE`   | 信号量集大小，固定为1（仅使用单个信号量）                    |
| `SEM_INIT_VAL`   | 信号量默认初始值，固定为1                                    |
| `SUCCESS`/`FAIL` | 测试结果标识，`SUCCESS=1`表示通过，`FAIL=-1`表示失败         |
| `ARG_BUF_SZ`     | 子进程参数缓冲区大小，固定为64字节                           |
| `prog_name`      | 子进程执行程序路径，固定为`/bin/sem`                         |

测试套件通过以下标识区分不同测试场景，用于父进程向子进程传递测试类型：

| 标识                     | 测试场景                               |
| ------------------------ | -------------------------------------- |
| `TEST_GET_SEMID_BY_KEY`  | 通过key获取信号量ID（基础功能验证）    |
| `TEST_PROCESS_SYNC`      | 进程间信号量同步（核心功能验证）       |
| `TEST_IMMEDIATELY_RMSEM` | 立即删除信号量后的行为验证（异常场景） |
| `TEST_OPERATE_DESTOYED`  | 操作已销毁的信号量（异常场景）         |
| `TEST_NO_RMSEM`          | 不主动删除信号量（资源泄漏检测）       |

测试参数个数宏定义各测试用例所需的子进程参数个数（argv长度），用于参数合法性检查：

| 宏定义                       | 参数个数 | 对应测试类型            |
| ---------------------------- | -------- | ----------------------- |
| `TEST_GET_SEMID_BY_KEY_ARGC` | 5        | `TEST_GET_SEMID_BY_KEY` |
| `TEST_PROCESS_SYNC_ARGC`     | 4        | `TEST_PROCESS_SYNC`     |
| `TEST_OPERATE_DESTOYED_ARGC` | 5        | `TEST_OPERATE_DESTOYED` |

日志打印宏 `INFO`：

```c
#define INFO(fmt, ...)   do { \
    printf("\t\t[SEM TEST] [file: %s, line: %d, func: %s] " fmt, \
    __FILE__, __LINE__, __func__, ##__VA_ARGS__); \
} while (0)
```

- 功能：打印包含文件名、行号、函数名的详细日志，便于定位问题
- 使用场景：所有测试用例中的状态输出与错误提示

子进程执行函数 `execute_in_child`：

```c
static int execute_in_child(char **const child_argv);
```

- 功能：创建子进程执行指定测试逻辑，并检查子进程退出状态
- 实现逻辑：
    1. 使用`posix_spawn`创建子进程，执行`prog_name`指定的程序
    2. 通过`waitpid`等待子进程退出，获取退出状态
    3. 验证子进程是否正常退出且返回码为0，返回`SUCCESS`或`FAIL`
- 返回值：`SUCCESS`表示子进程测试通过，`FAIL`表示失败



子进程根据父进程传递的`TEST_*`类型标识，执行对应测试逻辑，与父进程协作完成跨进程场景验证：

| 子进程函数                         | 对应测试类型            | 功能                                                     |
| ---------------------------------- | ----------------------- | -------------------------------------------------------- |
| `child_test_get_semid_by_key`      | `TEST_GET_SEMID_BY_KEY` | 验证子进程通过key获取的semid与父进程一致，且信号量值正确 |
| `child_test_process_sync`          | `TEST_PROCESS_SYNC`     | 执行V操作，将信号量值从0恢复为1，验证跨进程同步          |
| `child_test_operate_destroyed_sem` | `TEST_OPERATE_DESTOYED` | 验证对已销毁信号量的key获取和semid操作均返回正确错误码   |



### 1.1 test_semget_semid_from_key

测试目的：验证通过key创建、获取信号量ID的基础功能及错误处理。

测试场景：

1. 获取不存在的信号量 → 预期返回`ENOENT`错误
2. 新建信号量（带`IPC_CREAT|IPC_EXCL`）→ 成功获取semid
3. 同一进程通过key再次获取 → 验证semid与初始值一致
4. 重复新建（带`IPC_EXCL`）→ 预期返回`EEXIST`错误
5. 子进程通过key获取 → 验证与父进程semid一致

关键步骤：

- 生成随机key避免冲突
- 使用`semget`系统调用执行创建/获取操作
- 通过`semctl(SETVAL)`设置初始值，`semctl(GETVAL)`验证值正确性
- 子进程通过参数传递key和预期semid，验证跨进程一致性




### 1.2  test_process_sync

测试目的：验证信号量在进程间的同步能力（P/V操作的跨进程生效）。

测试逻辑：

1. 父进程创建匿名信号量（`IPC_PRIVATE`，仅父子进程可见），初始值设为1
2. 父进程执行P操作（信号量值从1→0）
3. 子进程执行V操作（信号量值从0→1）
4. 父进程验证信号量值回到1，确认同步生效

关键步骤：

- 使用`struct sembuf`定义P操作（`sem_op=-1`）和V操作（`sem_op=1`）
- 通过`semop`系统调用执行P/V操作
- 子进程通过参数获取semid，执行V操作后验证值正确性




### 1.3 test_immediately_rmsem

测试目的：验证信号量被立即删除后，后续操作的错误处理正确性。

测试逻辑：

1. 创建信号量后立即通过`semctl(IPC_RMID)`删除
2. 对已删除的semid执行`semctl(IPC_STAT)`操作（分别传入空缓冲区和非空缓冲区）
3. 验证两次操作均返回`EINVAL`错误

关键意义：确保信号量删除后资源彻底释放，避免无效句柄的误操作。



### 1.4 test_operate_destroyed_sem

测试目的：验证对已销毁信号量的操作是否返回正确错误码。

测试逻辑：

1. 父进程创建信号量并设置初始值，随后立即删除
2. 子进程尝试通过原key获取信号量 → 预期返回`ENOENT`
3. 子进程尝试对已删除的semid执行P操作 → 预期返回`EINVAL`

关键意义：验证信号量销毁后，无论是通过key还是原semid操作均能正确报错。




### 1.5 test_no_rmsem

测试目的：验证系统在信号量未被显式删除时的资源回收能力。

测试逻辑：

1. 创建信号量并设置初始值，但不执行`IPC_RMID`删除操作
2. 作为最后一个测试用例，依赖系统退出时的资源回收机制

关键意义：检测系统是否存在信号量资源泄漏，确保未显式删除的资源能被自动回收。



## 二、Linux Test Project(LTP)

https://github.com/linux-test-project/ltp/tree/20210927

### 2.0 测试方式

```bash
cd demos/linux-ltp  
bash dl_and_build_ltp.sh  
SGX_MODE=SIM  ./prepare_ltp.sh  
cd occlum_instance  
occlum run /opt/ltp/run-ltp.sh -f syscalls-occlum
```

其中最后一条命令可以通过 `-s` 指定测例，例如 

```bash
occlum run /opt/ltp/run-ltp.sh -f syscalls-occlum -s semop02
```


### 2.1 semget 测例

#### semget01

- 功能：测试 semget () 函数能否正确创建信号量集，通过调用 semget () 创建信号量集并检查返回值，同时验证信号量集的信号量数量及用户 ID 等基本属性是否正确。

- 结果：通过

```
INFO: Test case: semget01
INFO: ... Commands: semget01
semget01    1  TPASS  :  basic semaphore values are okay
```

#### semget03

- 功能：用于测试当使用有效 key 但无关联信号量集且不指定 IPC_CREAT 时，semget () 是否正确返回 ENOENT 错误。
- 结果：通过

```
INFO: Test case: semget03
INFO: ... Commands: semget03
semget03    1  TPASS  :  expected failure - errno = 2 : No such file or directory
```

#### semget05

- 功能：用于测试当系统信号量集数量达到上限时，semget () 是否正确返回 ENOSPC 错误，通过循环创建信号量集至系统限制后再尝试创建来验证。
- 结果：通过

```
INFO: Test case: semget05
INFO: ... Commands: semget05
semget05    1  TPASS  :  expected failure - errno = 28 : No space left on device
```

#### semget06

- 功能：该测例通过使用过大（1024*32）和过小（-1）的信号量数量调用 semget ()，测试其是否正确返回 EINVAL 错误。

- 结果：通过（共2个测试点）

```
INFO: Test case: semget06
INFO: ... Commands: semget06
semget06    1  TPASS  :  expected failure - errno = 22 : Invalid argument
semget06    2  TPASS  :  expected failure - errno = 22 : Invalid argument
```



### 2.2 semctl 测例

#### semctl01

- 调整：需要把 fork 全部替换为 posix_spawn，以适配 occlum。
- 功能：该测例针对 semctl () 的 13 种命令进行详细测试，每种命令的测试逻辑如下：
    1. IPC_STAT：获取信号量集的状态信息（存于 struct semid_ds），验证信号量数量（sem_nsems）是否为预设值 PSEMS，以及权限模式（sem_perm.mode）是否正确。
    2. IPC_SET：修改信号量集的属性（此处修改权限模式），先通过 setup 函数设置新权限（SEM_RA | NEWMODE），再验证修改后权限是否生效。
    3. GETALL：获取信号量集中所有信号量的值，检查初始状态下所有信号量值是否为 0。
    4. GETNCNT：获取等待该信号量值增加的进程数。通过创建 NCHILD 个子进程使其阻塞等待信号量值增加，验证返回的进程数是否为 NCHILD。
    5. GETPID：获取最后操作该信号量的进程 ID。通过子进程对信号量执行递增操作，验证返回的 PID 是否为该子进程 ID。
    6. GETVAL：获取单个信号量的值，验证目标信号量值是否为预期的 1（由前序操作设置）。
    7. GETZCNT：获取等待该信号量值为 0 的进程数。创建 NCHILD 个子进程使其阻塞等待信号量值为 0，验证返回的进程数是否为 NCHILD。
    8. SETALL：设置信号量集中所有信号量的值（此处设为 3），通过 GETALL 验证所有信号量值是否正确更新。
    9. SETVAL：设置单个信号量的值（此处设为 2），通过 GETVAL 验证该信号量值是否正确更新。
    10. IPC_INFO：获取系统级信号量信息（存于 struct seminfo），验证返回的最高信号量索引是否有效。
    11. SEM_INFO：获取信号量集的统计信息，验证系统中信号量集的数量是否合理（大于等于 1）。
    12. SEM_STAT：根据索引获取信号量集的 ID，验证返回的 ID 是否为目标信号量集的有效 ID。
    13. IPC_RMID：删除信号量集，验证删除后对该信号量集的操作是否返回 EINVAL 错误，确认资源已释放。

- 结果：LTP 的代码逻辑不支持直接将 fork 修改位 posix_spawn。将该测例移出 LTP，将 fork 替换为 posix_spawn后，以上测试点全部通过。



#### semctl03

- 功能：该测例测试 semctl () 的 EINVAL 和 EFAULT 错误，包含 4 个子测试点：
    1. 使用无效 IPC 命令（-1），测试是否返回 EINVAL；
    2. 使用无效信号量 ID，测试是否返回 EINVAL；
    3. 使用无效 union 参数执行 GETALL 命令，测试是否返回 EFAULT；
    4. 使用无效 union 参数执行 IPC_SET 命令，测试是否返回 EFAULT，同时覆盖 libc 的 semctl () 和__NR_semctl 系统调用两种变体。
- 结果：全部通过。

```
INFO: Test case: semctl03
INFO: ... Commands: semctl03
tst_test.c:1389: TINFO: In Child process ...

semctl03.c:82: TINFO: Testing variant: libc semctl()
semctl03.c:73: TPASS: semctl() with invalid IPC command : EINVAL (22)
semctl03.c:73: TPASS: semctl() with invalid sem id : EINVAL (22)
semctl03.c:69: TCONF: EFAULT is skipped for libc variant
semctl03.c:69: TCONF: EFAULT is skipped for libc variant
tst_test.c:1389: TINFO: In Child process ...

semctl03.c:82: TINFO: Testing variant: __NR_semctl syscall
semctl03.c:73: TPASS: semctl() with invalid IPC command : EINVAL (22)
semctl03.c:73: TPASS: semctl() with invalid sem id : EINVAL (22)
semctl03.c:73: TPASS: semctl() with invalid union arg : EFAULT (14)
semctl03.c:73: TPASS: semctl() with invalid union arg : EFAULT (14)

Summary:
passed   6
failed   0
broken   0
skipped  2
warnings 0
```



#### semctl05

- 功能：该测例测试调用 semctl () 执行 SETVAL（设置负数或过大值）和 SETALL（设置过大值）操作时是否返回 ERANGE 错误。
- 结果：全部通过。

```
INFO: Test case: semctl05
INFO: ... Commands: semctl05
tst_test.c:1389: TINFO: In Child process ...

semctl05.c:44: TPASS: semctl() with the value to set is less than zero : ERANGE (34)
semctl05.c:44: TPASS: semctl() with the value to set are too large : ERANGE (34)
semctl05.c:44: TPASS: semctl() with the value to set is too large : ERANGE (34)

Summary:
passed   3
failed   0
broken   0
skipped  0
warnings 0
```



#### semctl06

- 功能：该测例通过多进程及子进程对信号量集进行多次 semop 操作，最终用 semctl 检查信号量值是否与初始设置一致，验证 semctl、semget、semop 等函数的正确性。
- 结果：LTP 的代码逻辑不支持直接将 fork 修改位 posix_spawn。将该测例移出 LTP，将 fork 替换为 posix_spawn后，以上测试点全部通过。



#### semctl07

- 功能：该测例对 semctl () 函数的基本功能进行测试，包括 IPC_STAT、SETVAL、GETVAL、GETPID、GETNCNT、GETZCNT 等命令的正确性验证。包含若干子测例：
    1. IPC_STAT 命令测试：获取信号量集的 semid_ds 结构体信息，验证其中的信号量数量（sem_nsems）、所有者 UID/GID、创建者 UID/GID 是否与预期一致（匹配当前进程的 ID）。
    2. GETVAL 命令测试：验证通过 GETVAL 命令获取信号量初始值的操作是否成功。
    3. SETVAL 命令测试：验证通过 SETVAL 命令将信号量值设置为 1 的操作是否成功。
    4. GETVAL 值一致性测试：再次使用 GETVAL 命令，验证获取的信号量值与通过 SETVAL 设置的值（1）是否一致。
    5. GETPID 命令测试：验证通过 GETPID 命令获取的 “最后操作信号量的进程 ID” 是否与当前进程 ID 一致。
    6. GETNCNT 命令测试：验证通过 GETNCNT 命令获取的 “等待信号量值增加的进程数” 是否为 0（无等待进程）。
    7. GETZCNT命令测试：验证通过 GETZCNT 命令获取的 “等待信号量值为 0 的进程数” 是否为 0（无等待进程）。
- 结果：全部通过

```
INFO: Test case: semctl07
INFO: ... Commands: semctl07
tst_test.c:1389: TINFO: In Child process ...

semctl07.c:38: TPASS: semctl(semid, 0, IPC_STAT, arg) passed
semctl07.c:44: TPASS: sem_nsems = 1
semctl07.c:51: TPASS: sem_perm.uid = 0
semctl07.c:58: TPASS: sem_perm.gid = 0
semctl07.c:65: TPASS: sem_perm.cuid = 0
semctl07.c:72: TPASS: sem_perm.cgid = 0
semctl07.c:78: TPASS: semctl(GETVAL) succeeded
semctl07.c:85: TPASS: semctl(SETVAL) succeeded
semctl07.c:90: TPASS: semctl(GETVAL) succeeded
semctl07.c:96: TPASS: semctl(GETVAL) returned 1
semctl07.c:102: TPASS: semctl(GETPID) succeeded
semctl07.c:108: TPASS: semctl(GETPID) returned 23
semctl07.c:114: TPASS: semctl(GETNCNT) succeeded
semctl07.c:120: TPASS: semctl(GETNCNT) returned 0
semctl07.c:125: TPASS: semctl(GETZCNT) succeeded
semctl07.c:130: TPASS: semctl(GETZCNT) succeeded 0

Summary:
passed   16
failed   0
broken   0
skipped  0
warnings 0
```



#### 移除的测例

- semctl02：该测例测试使用 nobody 用户调用 semctl () 执行 IPC_STAT 操作时是否返回 EACCES 错误。由于 Occlum 为单用户系统，该测例无意义，但不会导致系统崩溃。
- semctl04：该测例测试非特权子进程（使用 nobody 用户）调用 semctl () 执行 IPC_SET 和 IPC_RMID 操作时是否返回 EPERM 错误。由于 Occlum 为单用户系统，该测例无意义，但不会导致系统崩溃。
- semctl08：该测例用于验证内核是否会将 semid64_ds 结构中的 sem_otime_high 和 sem_ctime_high 字段清零。在Occlum 中该测例无意义，但不会导致系统崩溃。
- semctl09：该测例通过 SEM_INFO 和 SEM_STAT_ANY 标志调用 semctl ()，检查返回索引的有效性、有效索引计数与 semusz 的一致性及数据与 /proc/sysvipc/sem 的一致性，并测试系统调用和 libc 函数在 nobody 用户与 root 用户下的表现。

### 2.3 semop 测例

这部分测例同时测试了 `semop` 和 `semtimedop` 功能。

#### semop01

- 功能：该测例测试 semop() 和 semtimedop() 的基本功能正确性，通过执行带 SEM_UNDO 标志的信号量操作（设置信号量值为 i*i），在无超时和 10000 纳秒超时两种场景下，验证操作后信号量值是否符合预期。
- 结果：全部通过

```
INFO: Restricted to semop01
INFO: Test case: semop01
INFO: ... Commands: semop01
tst_test.c:1389: TINFO: In Child process ...

semop01.c:71: TINFO: Testing variant: semop: syscall
semop01.c:58: TPASS: semaphore values are correct
semop01.c:58: TPASS: semaphore values are correct
tst_test.c:1389: TINFO: In Child process ...

semop01.c:71: TINFO: Testing variant: semtimedop: syscall with old kernel spec
semop01.c:58: TPASS: semaphore values are correct
semop01.c:58: TPASS: semaphore values are correct

Summary:
passed   4
failed   0
broken   0
skipped  0
warnings 0
```



#### semop02：

- 功能：该测例通过 13 个测试点验证`semop`和`semtimedop`系统调用在不同异常场景下的错误处理能力。

    - 操作数超过系统最大限制，预期返回E2BIG。   

    - 对无权限信号量执行操作，预期返回EACCESS。   

    - 传递无效地址的sembuf结构体，预期返回EFAULT。   

    - 操作数为0（非正数），预期返回EINVAL。   

    - 使用无效信号量ID，预期返回EINVAL。   

    - 操作值导致信号量值超出上限，预期返回ERANGE。   

    - 信号量编号为负数，预期返回EFBIG。   

    - 信号量编号超出集合范围，预期返回EFBIG。  

    - sem_op=0且非阻塞时信号量非0，预期返回EAGAIN。   

    - sem_op=-1且非阻塞时信号量为0，预期返回EAGAIN。   

    - semtimedop中sem_op=0超时，预期返回EAGAIN。   

    - semtimedop中sem_op=-1超时，预期返回EAGAIN。   

    - semtimedop中传递无效超时地址，预期返回EFAULT。

- 结果：Occlum 为单用户系统，不支持nobody用户测例。将该测例移出 LTP，并取消 nobody 的测试，以上测试点全部通过。



#### semop03

- 功能：该测例测试 semop () 在两种场景下的错误返回：信号量集被删除时是否返回 EIDRM，进程收到信号时是否返回 EINTR。
- 结果：LTP 的代码逻辑不支持直接将 fork 修改位 posix_spawn。将该测例移出 LTP，将 fork 替换为 posix_spawn后，以上测试点全部通过。



## 三、ProgreSQL

### 3.1 PostgreSQL 使用 System V 信号量调研

PostgreSQL 是多进程架构，多个后端进程（backend）、辅助进程（如 bgwriter、checkpointer）需要共享内存中的数据结构（如缓冲区、锁表）。SystemV 信号量的核心作用是提供互斥与同步机制，防止多个进程同时修改关键资源导致数据不一致。

例如：当一个进程需要修改共享内存中的缓冲区时，会通过 SystemV 信号量获取锁；操作完成后释放锁，其他进程才能继续访问。

PostgreSQL 16 默认支持 SystemV 信号量（除非编译时明确禁用）。

PostgreSQL 16 启动时会创建 SystemV 信号量集，其数量依赖于数据库的并发配置（如最大连接数）。需确保操作系统的 SystemV 信号量参数满足需求，否则会启动失败。

当 `pg_ctl start` 启动数据库时，postmaster（主进程）会根据配置计算所需信号量数量，通过 SystemV 接口（`semget`）创建信号量集，并初始化信号量值（`semctl`）。

后端进程或辅助进程需要访问共享资源时，通过 `semop` 系统调用操作信号量：

- 申请资源：尝试获取信号量（如将信号量值从 1 减为 0）。
- 释放资源：操作完成后释放信号量（如将信号量值从 0 加为 1）

正常关闭时，postmaster 会通过 `semctl` 销毁信号量集；若异常关闭（如 kill -9），信号量集可能残留，需手动清理。

### 3.2 移植 PostgreSQL 到 Occlum

目前已经做了一些尝试，但仍未全部完成。

下载并编译 postgresql:
```bash
#!/bin/bash
set -e

apt update -y
apt install -y \
    build-essential \
    libreadline-dev \
    zlib1g-dev \
    flex \
    bison \
    libuuid1 \
    libossp-uuid-dev \
    pkg-config \
    wget

PG_VERSION="16.3"             
PG_SOURCE_TAR="postgresql-${PG_VERSION}.tar.bz2"
PG_SOURCE_URL="https://mirrors.tuna.tsinghua.edu.cn/postgresql/source/v${PG_VERSION}/${PG_SOURCE_TAR}"
PG_INSTALL_DIR="/usr/local/pgsql" 


# Prepare source code
rm -rf postgresql-16.3
wget -c "${PG_SOURCE_URL}" -O "${PG_SOURCE_TAR}"
tar -xjvf "${PG_SOURCE_TAR}" 
# patch -s -p0 < apply_root.patch
cd "postgresql-${PG_VERSION}"


# Compile and install
./configure \
    --prefix="${PG_INSTALL_DIR}" \
    --enable-thread-safety \
    --disable-largefile|| {
    echo "配置失败，请检查依赖是否齐全"
    exit 1
}


make -j4
make install -j$(nproc)
```

运行 postgresql 服务器：
```bash
#!/bin/bash  
set -e  

GREEN='\033[1;32m'
NC='\033[0m'

# Occlum 实例配置  
OCCLUM_INSTANCE_DIR="occlum_postgres_instance"  
PG_INSTALL_DIR="/usr/local/pgsql"  
PG_DATA_DIR="${PG_INSTALL_DIR}/data"  

# 1. Init Occlum instance
echo -e "${GREEN}=== Create Occlum Instance ===${NC}"  
rm -rf occlum_instance && occlum new occlum_instance
pushd occlum_instance

new_json="$(jq '.resource_limits.user_space_size = "512MB" |
                .resource_limits.user_space_max_size = "1GB" |  
                .resource_limits.kernel_space_heap_size ="64MB" |  
                .resource_limits.kernel_space_heap_max_size ="256MB" |  
                .resource_limits.max_num_of_threads = 128 |  
                .entry_points = ["/usr/local/pgsql/bin"] |
                .env.default = ["OCCLUM=yes", "PATH=/usr/local/pgsql/bin:/usr/bin:/bin"]' Occlum.json)" && \
echo "${new_json}" > Occlum.json

# 2. Copy files into Occlum instance and build
rm -rf image  
copy_bom -f ../psql.yaml --root image --include-dir /opt/occlum/etc/template  
occlum build
occlum start

# 3. Run the program
echo -e "${GREEN}=== Initialize PostgreSQL... ===${NC}"  
occlum exec /usr/local/pgsql/bin/initdb -D ${PG_DATA_DIR} --auth-local=trust  > output.log

echo -e "${GREEN}=== Launch PostgreSQL Server... ===${NC}"  
occlum exec /usr/local/pgsql/bin/postgres -D ${PG_DATA_DIR}  > output.log
```

postgresql 需要修改源码。首先是 postgresl 官方明确要求不允许在 root 用户中运行，所以需要删掉检测 root 用户的逻辑。

```cpp
// src/backend/main/main.c

static void
check_root(const char *progname)
{
#ifndef WIN32
	if (geteuid() == 0)
	{
		write_stderr("\"root\" execution of the PostgreSQL server is not permitted.\n"
					 "The server must be started under an unprivileged user ID to prevent\n"
					 "possible system security compromise.  See the documentation for\n"
					 "more information on how to properly start the server.\n");
		exit(1);
	}

	/*
	 * Also make sure that real and effective uids are the same. Executing as
	 * a setuid program from a root shell is a security hole, since on many
	 * platforms a nefarious subroutine could setuid back to root if real uid
	 * is root.  (Since nobody actually uses postgres as a setuid program,
	 * trying to actively fix this situation seems more trouble than it's
	 * worth; we'll just expend the effort to check for it.)
	 */
	if (getuid() != geteuid())
	{
		write_stderr("%s: real and effective user IDs must match\n",
					 progname);
		exit(1);
	}
#else							/* WIN32 */
	if (pgwin32_is_admin())
	{
		write_stderr("Execution of PostgreSQL by a user with administrative permissions is not\n"
					 "permitted.\n"
					 "The server must be started under an unprivileged user ID to prevent\n"
					 "possible system security compromises.  See the documentation for\n"
					 "more information on how to properly start the server.\n");
		exit(1);
	}
#endif							/* WIN32 */
}

```

```cpp
// src/bin/initdb/initdb.c
static char *
get_id(void)
{
	const char *username;

#ifndef WIN32
	if (geteuid() == 0)			/* 0 is root's uid */
	{
		pg_log_error("cannot be run as root");
		pg_log_error_hint("Please log in (using, e.g., \"su\") as the (unprivileged) user that will own the server process.");
		exit(1);
	}
#endif
```

目前遇到的主要问题是内存问题导致的崩溃，例如报错 `popen failure: Cannot allocate memory`。经定位，该报错出现在:
```cpp
//src/bin/initdb
int
find_other_exec(const char *argv0, const char *target,
				const char *versionstr, char *retpath)
{
	char		cmd[MAXPGPATH];
	char	   *line;

	if (find_my_exec(argv0, retpath) < 0)
		return -1;

	/* Trim off program name and keep just directory */
	*last_dir_separator(retpath) = '\0';
	canonicalize_path(retpath);

	/* Now append the other program's name */
	snprintf(retpath + strlen(retpath), MAXPGPATH - strlen(retpath),
			 "/%s%s", target, EXE);

	if (validate_exec(retpath) != 0)
		return -1;

	snprintf(cmd, sizeof(cmd), "\"%s\" -V", retpath);

	if ((line = pipe_read_line(cmd)) == NULL)
		return -1;

	if (strcmp(line, versionstr) != 0)
	{
		pfree(line);
		return -2;
	}

	pfree(line);
	return 0;
}
```
相似的报错还会出现在其他地方，且相互影响。目前还没有找到一套完整的结局方案。